## 容错虚拟机

## 摘要

我们实现了一个商业企业级系统，用于提供容错虚拟机，其基础是通过另一台服务器上的备份虚拟机复制主虚拟机（VM）的执行。我们在VMware vSphere 4.0中设计了一个完整的系统，该系统易于使用，在普通服务器上运行，并且通常会将实际应用程序的性能降低不到10%。此外，对于一些实际应用，保持主、辅虚拟机以锁步(lockstep)方式执行所需的数据带宽小于20 Mbit/s，这允许在更长的距离上实现容错。一个易于使用、商业化的系统，在故障后自动恢复冗余，除了复制的VM执行之外，还需要许多其他组件。我们设计并实现了这些额外的组件，并解决了在支持运行企业应用程序的vm时遇到的许多实际问题。在本文中，我们描述了我们的基本设计，讨论了可选的设计选择和一些实现细节，并为微基准测试和实际应用程序提供了性能结果。

## 简介

实现容错服务器的一种常见方法是主/备份方法[1]，在主服务器发生故障时，备份服务器始终可以接管。备份服务器的状态必须始终与主服务器保持几乎相同，这样当主服务器发生故障时，备份服务器可以立即接管主服务器，并且以这样的方式，故障对外部客户端是隐藏的，并且不会丢失任何数据。在备份服务器上复制状态的一种方法是几乎连续地将对主服务器的所有状态（包括CPU、内存和I/O设备）的更改发送到备份。然而，发送这种状态所需的带宽，特别是内存中的变化，可能非常大。

另一种可以使用更少带宽来复制服务器的方法有时被称为状态机方法[13]。其思想是将服务器建模为确定性状态机，通过从相同的初始状态启动服务器并确保它们以相同的顺序接收相同的输入请求，从而保持同步。由于大多数服务器或服务都有一些不确定的操作，因此必须使用额外的协调来确保主服务器和备份保持同步。但是，保持主服务器和备份服务器同步所需的额外信息量远远小于主服务器中正在更改的状态量（主要是内存更新）

实现协调以确保物理服务器的确定性执行[14]很困难，特别是随着处理器频率的增加。相比之下，运行在hypervisor之上的虚拟机（VM）是实现状态机方法的优秀平台。虚拟机可以被视为定义良好的状态机，其操作是被虚拟化的机器（包括其所有设备）的操作。与物理服务器一样，vm有一些不确定的操作（例如读取一天中的时钟或传递一个中断），因此必须向备份发送额外的信息，以确保它保持同步。由于hypervisor完全控制VM的执行，包括所有输入的传递，hypervisor能够捕获关于主VM上非确定性操作的所有必要信息，并在备份VM上正确地重放这些操作。因此，状态机方法可以在商品硬件上实现虚拟机，而无需修改硬件，从而可以立即为最新的微处理器实现容错。此外，状态机方法所需的低带宽允许将主服务器和备份服务器进行更大的物理分离。例如，复制的虚拟机可以在分布在校园内的物理机上运行，这比运行在同一栋楼里的虚拟机提供了更高的可靠性。我们在VMware vSphere 4.0平台上使用主/备份方法实现了容错虚拟机，该平台以高效的方式运行完全虚拟化的x86虚拟机。由于VMware vSphere实现了一个完整的x86虚拟机，因此我们能够自动为任何x86操作系统和应用程序提供容错。允许我们记录主服务器执行情况并确保备份执行相同的基本技术称为确定性重放[15]。VMware vSphere容错（FT）基于确定性重放，但添加了必要的额外协议和功能来构建完整的容错系统。除了提供硬件容错之外，我们的系统在发生故障后通过在本地群集中的任何可用服务器上启动新的备份虚拟机来自动恢复冗余。此时，deterministic replay和VMware FT的生产版本仅支持单处理器虚拟机。记录和回放多处理器虚拟机的执行仍在进行中，存在严重的性能问题，因为几乎所有对共享内存的访问都可能是非确定性操作。Bressoud和Schneider[3]描述了一个用于HP PA-RISC平台的容错VMs的原型实现。我们的方法是相似的，但是出于性能的考虑，我们做了一些根本性的改变，并研究了一些设计方案。此外，我们还必须在系统中设计和实现许多附加组件，并处理许多实际问题，以构建一个完整的系统，该系统对于运行企业应用程序的客户来说是高效和可用的。与所讨论的大多数其他实际系统类似，我们只尝试处理fail-stop故障[12]，这些故障是在发生故障的服务器导致不正确的外部可见操作之前可以检测到的服务器故障。论文的其余部分安排如下。首先，我们描述了我们的基本设计并详细说明了我们的基本协议，这些协议确保在主虚拟机发生故障后备份虚拟机接管时不会丢失数据。然后，我们详细描述了构建一个健壮、完整和自动化系统所必须解决的许多实际问题。我们还描述了实现容错VMs的几种设计选择，并讨论了这些选择的折衷。接下来，我们将给出一些基准测试和一些实际企业应用程序的实现的性能结果。最后，对相关工作进行了描述和总结。基于性能原因进行了根本性的改变，并调查了一些设计方案。此外，我们还必须在系统中设计和实现许多附加组件，并处理许多实际问题，以构建一个完整的系统，该系统对于运行企业应用程序的客户来说是高效和可用的。与所讨论的大多数其他实际系统类似，我们只尝试处理fail-stop故障[12]，这些故障是在发生故障的服务器导致不正确的外部可见操作之前可以检测到的服务器故障。